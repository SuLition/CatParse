# 视频解析下载技术方案

## 一、整体架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                      API 层 (FastAPI)                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  /api/parse  │  │ /api/download│  │   /health    │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│                   工厂模式 (DownloaderFactory)               │
│    根据平台名称动态创建对应的 Downloader 实例                 │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│                   下载器层 (Downloaders)                     │
│  ┌────────────────────────────────────────────────────┐     │
│  │              BaseDownloader (抽象基类)              │     │
│  └────────────────────────────────────────────────────┘     │
│            ▲         ▲         ▲         ▲                  │
│  ┌─────────┴───┐ ┌───┴───┐ ┌───┴───┐ ┌───┴───┐             │
│  │DouyinDL    │ │BiliDL │ │XhsDL  │ │KsDL   │ ...          │
│  └─────────────┘ └───────┘ └───────┘ └───────┘             │
└─────────────────────────────────────────────────────────────┘
```

## 二、技术栈

| 组件 | 技术 | 用途 |
|------|------|------|
| Web框架 | FastAPI | 后端 API 服务 |
| HTTP请求 | requests + urllib3 | 网页抓取与下载 |
| HTML解析 | BeautifulSoup (lxml) | 解析网页提取数据 |
| JS执行 | py-mini-racer | 执行抖音签名 JS |
| 配置管理 | python-dotenv | 环境变量管理 |

## 三、核心设计模式

### 1. 工厂模式 (Factory Pattern)

```python
class DownloaderFactory:
    """下载器工厂 - 根据平台名称创建对应的下载器实例"""
    platform_to_downloader = {
        "小红书": XiaohongshuDownloader,
        "抖音": DouyinDownloader,
        "快手": KuaishouDownloader,
        "哔哩哔哩": BilibiliDownloader,
        "好看视频": HaokanDownloader,
        "微视": WeishiDownloader,
        "梨视频": LishipinDownloader,
        "皮皮搞笑": PipigaoxiaoDownloader
    }

    @staticmethod
    def create_downloader(platform, real_url):
        downloader_class = DownloaderFactory.platform_to_downloader.get(platform)
        return downloader_class(real_url)
```

**扩展新平台**：只需新增下载器类并注册到字典即可。

### 2. 模板方法模式 (Template Method Pattern)

```python
class BaseDownloader:
    def __init__(self, real_url):
        self.real_url = real_url
        self.headers = None
        self.html_content = None

    # ========== 抽象方法 - 子类必须实现 ==========
    def get_real_video_url(self):
        """获取视频真实下载地址"""
        raise NotImplementedError

    def get_title_content(self):
        """获取视频标题"""
        raise NotImplementedError

    def get_cover_photo_url(self):
        """获取封面图URL"""
        raise NotImplementedError

    # ========== 通用方法 - 所有子类共享 ==========
    def fetch_html_content(self):
        """获取网页HTML内容"""
        resp = requests.get(self.real_url, headers=self.headers, timeout=5)
        resp.raise_for_status()
        return resp.text

    @staticmethod
    def parse_html_data(html_content, pattern):
        """从HTML的<script>标签中提取JSON数据"""
        page_obj = BeautifulSoup(html_content, 'lxml')
        script_tags = page_obj.find_all('script')
        for script in script_tags:
            if script.string:
                match = pattern.search(script.string)
                if match:
                    json_data = match.group(1)
                    json_data = json_data.rstrip(';')
                    json_data = json_data.replace('undefined', 'null')
                    return json_data
        return None

    def download_and_save(self, folder, url, file_extension):
        """带重试机制的流式下载"""
        retries = Retry(total=5, backoff_factor=1, status_forcelist=[500, 502, 503, 504])
        session = requests.Session()
        session.mount('http://', HTTPAdapter(max_retries=retries))
        session.mount('https://', HTTPAdapter(max_retries=retries))
        
        response = session.get(url, headers=self.headers, stream=True)
        filename = os.path.join(folder, f'{uuid.uuid4()}.{file_extension}')
        with open(filename, "wb") as f:
            for chunk in response.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
        return filename
```

## 四、各平台解析方案

### 解析方案对照表

| 平台 | 数据来源 | 正则表达式 | 特殊处理 |
|------|----------|------------|----------|
| **抖音** | API接口 | - | 需 `a_bogus` 签名 |
| **哔哩哔哩** | `window.__playinfo__` | `window\.__playinfo__\s*=\s*(\{.*\})` | 音视频分离 |
| **小红书** | `window.__INITIAL_STATE__` | `window\.__INITIAL_STATE__\s*=\s*(\{.*\})` | 重试机制(5次) |
| **快手** | `window.__APOLLO_STATE__` | `window\.__APOLLO_STATE__\s*=\s*(\{.*\};)` | 需登录Cookie |
| **好看视频** | `window.__PRELOADED_STATE__` | `window\.__PRELOADED_STATE__\s*=\s*(\{.*\};)` | URL解码 |

### 4.1 抖音下载器

**特点**：需要通过 JS 生成 `a_bogus` 签名参数

```python
class DouyinDownloader(BaseDownloader):
    def __init__(self, real_url):
        super().__init__(real_url)
        self.common_utils = CommonUtils()  # JS签名工具
        self.headers = {
            'User-Agent': self.common_utils.user_agent,
            'sec-ch-ua': '"Google Chrome";v="123"',
            # ... 其他 headers
        }
        self.ms_token = self.common_utils.get_ms_token()
        self.aweme_id = UrlParser.get_video_id(self.real_url)
        self.data = self.fetch_html_data()

    def fetch_html_data(self):
        """通过API获取视频数据，需要签名"""
        play_url = f"https://www.douyin.com/aweme/v1/web/aweme/detail/?aweme_id={self.aweme_id}&msToken={self.ms_token}"
        # 生成 a_bogus 签名
        abogus = self.common_utils.get_abogus(play_url, self.common_utils.user_agent)
        url = f"{play_url}&a_bogus={abogus}"
        response = requests.get(url, headers=self.headers)
        return response.json()

    def get_real_video_url(self):
        video_data = self.data.get('aweme_detail', {}).get('video', {})
        # 优先从 bit_rate 获取高清视频
        bit_rate = video_data.get('bit_rate')
        if bit_rate and len(bit_rate) > 0:
            play_addr_list = bit_rate[0].get('play_addr', {}).get('url_list', [])
            if len(play_addr_list) > 2:
                return play_addr_list[2]
        return None
```

**抖音签名工具** (`bogus_sign_utils.py`)：

```python
from py_mini_racer import MiniRacer

class CommonUtils:
    def __init__(self):
        self.user_agent = 'Mozilla/5.0 ...'
        # 加载 JS 签名代码
        with open('a_bogus.js', 'r') as f:
            a_bogus_js_code = f.read()
        self.a_bogus_ctx = MiniRacer()
        self.a_bogus_ctx.eval(a_bogus_js_code)

    def get_abogus(self, req_url, user_agent):
        """生成 a_bogus 签名"""
        query = urllib.parse.urlparse(req_url).query
        abogus = self.a_bogus_ctx.call('generate_a_bogus', query, user_agent)
        return abogus

    def get_ms_token(self, length=107):
        """生成随机 ms_token"""
        base_str = 'ABCDEFGHIGKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789='
        return ''.join(random.choice(base_str) for _ in range(length))
```

### 4.2 哔哩哔哩下载器

**特点**：音视频分离，需分别获取

```python
class BilibiliDownloader(BaseDownloader):
    def __init__(self, real_url):
        super().__init__(real_url)
        self.headers = {
            'User-Agent': random.choice(USER_AGENT_PC),
            'referer': self.real_url  # B站必须带 Referer
        }
        self.data, self.data2 = self.fetch_html_data()

    def fetch_html_data(self):
        self.html_content = self.fetch_html_content()
        # 解析视频播放信息 (含视频/音频地址)
        pattern_playinfo = re.compile(r'window\.__playinfo__\s*=\s*(\{.*\})', re.DOTALL)
        json_data = BaseDownloader.parse_html_data(self.html_content, pattern_playinfo)
        # 解析视频元信息 (标题、封面等)
        pattern_initial = re.compile(r'window\.__INITIAL_STATE__\s*=\s*(\{.*\});', re.DOTALL)
        json_data2 = BaseDownloader.parse_html_data(self.html_content, pattern_initial)
        return json_data, json_data2

    def get_real_video_url(self):
        data_dict = json.loads(self.data)
        return data_dict['data']['dash']['video'][0]['baseUrl']

    def get_audio_url(self):
        """获取音频URL (B站特有)"""
        data_dict = json.loads(self.data)
        return data_dict['data']['dash']['audio'][0]['baseUrl']

    def get_title_content(self):
        data_dict = json.loads(self.data2)
        return data_dict['videoData']['title']

    def get_cover_photo_url(self):
        data_dict = json.loads(self.data2)
        return data_dict['videoData']['pic']
```

### 4.3 小红书下载器

**特点**：解析不稳定，需重试机制

```python
class XiaohongshuDownloader(BaseDownloader):
    def __init__(self, real_url):
        super().__init__(real_url)
        self.headers = {
            'User-Agent': 'Mozilla/5.0 ...',
            'Referer': 'https://www.xiaohongshu.com/',
            'Sec-Ch-Ua': '"Chromium";v="128"',
            # ... 完整浏览器模拟
        }
        self.data = self.fetch_html_data()

    def fetch_html_data(self):
        self.html_content = self.fetch_html_content()
        pattern = re.compile(r'window\.__INITIAL_STATE__\s*=\s*(\{.*\})', re.DOTALL)
        return BaseDownloader.parse_html_data(self.html_content, pattern)

    def get_real_video_url(self):
        data_dict = json.loads(self.data)
        first_note_id = data_dict['note']['firstNoteId']
        origin_video_key = data_dict['note']['noteDetailMap'][first_note_id]['note']['video']['consumer']['originVideoKey']
        video_key = origin_video_key.replace("\\u002F", "/")
        return "http://sns-video-bd.xhscdn.com/" + video_key
```

### 4.4 快手下载器

```python
class KuaishouDownloader(BaseDownloader):
    def __init__(self, real_url):
        super().__init__(real_url)
        self.headers = {
            'User-Agent': random.choice(USER_AGENT_PC),
            'referer': 'https://www.kuaishou.com/',
            'cookie': 'kpf=PC_WEB; clientid=3; ...'  # 需要登录Cookie
        }
        self.data = self.fetch_html_data()
        self.video_id = UrlParser.get_video_id(self.real_url)

    def fetch_html_data(self):
        self.html_content = self.fetch_html_content()
        pattern = re.compile(r'window\.__APOLLO_STATE__\s*=\s*(\{.*\};)', re.DOTALL)
        return BaseDownloader.parse_html_data(self.html_content, pattern)

    def get_real_video_url(self):
        data_dict = json.loads(self.data)
        video_url = data_dict['defaultClient']['VisionVideoSetRepresentation:1']['url']
        return video_url.replace("\u002F", "/")
```

## 五、URL处理工具

```python
class UrlParser:
    @staticmethod
    def get_url(text):
        """从文本中提取URL"""
        url_pattern = re.compile(r'\bhttps?:\/\/(?:www\.|[-a-zA-Z0-9.@:%_+~#=]{1,256}\.[a-zA-Z0-9()]{1,6})\b(?:[-a-zA-Z0-9()@:%_+.~#?&//=]*)?')
        match = url_pattern.search(text)
        return match.group() if match else None

    @staticmethod
    def get_domain(url):
        """获取URL域名"""
        parsed_url = urlparse(url)
        return parsed_url.netloc

    @staticmethod
    def get_video_id(url):
        """从URL中提取视频ID"""
        parsed_url = urlparse(url)
        query_params = parse_qs(parsed_url.query)
        # 优先从查询参数获取
        for key in ['vid', 'id']:
            if query_params.get(key):
                return query_params[key][0]
        # 从路径中获取
        path_segments = parsed_url.path.strip('/').split('/')
        return path_segments[-1] if path_segments else None

    @staticmethod
    def convert_to_https(url):
        """转换为 HTTPS"""
        if url and url.startswith('http://'):
            return 'https://' + url[7:]
        return url


class WebFetcher:
    @staticmethod
    def fetch_redirect_url(url, max_redirects=5):
        """获取重定向后的真实URL"""
        current_url = url
        for _ in range(max_redirects):
            resp = requests.get(current_url, allow_redirects=False, timeout=5)
            redirect_url = resp.headers.get("location")
            if redirect_url:
                if not redirect_url.startswith('http'):
                    redirect_url = urljoin(current_url, redirect_url)
                if DOMAIN_TO_NAME.get(UrlParser.get_domain(redirect_url)):
                    return UrlParser.extract_video_address(redirect_url)
                current_url = redirect_url
            else:
                break
        return None
```

## 六、配置管理

### 域名到平台映射 (`business_config.json`)

```json
{
  "DOMAIN_TO_NAME": {
    "www.xiaohongshu.com": "小红书",
    "www.douyin.com": "抖音",
    "www.iesdouyin.com": "抖音",
    "www.kuaishou.com": "快手",
    "www.bilibili.com": "哔哩哔哩",
    "haokan.baidu.com": "好看视频",
    "isee.weishi.qq.com": "微视",
    "www.pearvideo.com": "梨视频",
    "h5.pipigx.com": "皮皮搞笑"
  }
}
```

## 七、API接口设计

### 7.1 解析接口

```
POST /api/parse
Content-Type: application/json

请求体:
{
    "text": "分享链接文本或URL"
}

响应:
{
    "retcode": 200,
    "retdesc": "成功",
    "data": {
        "video_id": "视频ID",
        "platform": "平台名称",
        "title": "视频标题",
        "video_url": "视频下载地址",
        "cover_url": "封面图地址",
        "audio_url": "音频地址(仅B站)"
    },
    "succ": true
}
```

### 7.2 下载接口

```
POST /api/download
Content-Type: application/json

请求体:
{
    "video_url": "视频地址",
    "video_id": "视频ID"
}

响应:
{
    "retcode": 200,
    "retdesc": "成功",
    "data": {
        "download_url": "可下载的URL"
    },
    "succ": true
}
```

## 八、扩展新平台指南

### 步骤1：创建下载器类

```python
# src/downloaders/new_platform_downloader.py
import re
import json
from src.downloaders.base_downloader import BaseDownloader
from configs.logging_config import logger

class NewPlatformDownloader(BaseDownloader):
    def __init__(self, real_url):
        super().__init__(real_url)
        self.headers = {
            'User-Agent': '...',
            'referer': '...'
        }
        self.data = self.fetch_html_data()

    def fetch_html_data(self):
        self.html_content = self.fetch_html_content()
        pattern = re.compile(r'window\.__DATA__\s*=\s*(\{.*\})', re.DOTALL)
        return BaseDownloader.parse_html_data(self.html_content, pattern)

    def get_real_video_url(self):
        data_dict = json.loads(self.data)
        return data_dict['video']['url']

    def get_title_content(self):
        data_dict = json.loads(self.data)
        return data_dict['title']

    def get_cover_photo_url(self):
        data_dict = json.loads(self.data)
        return data_dict['cover']
```

### 步骤2：注册到工厂

```python
# src/downloader_factory.py
from src.downloaders.new_platform_downloader import NewPlatformDownloader

class DownloaderFactory:
    platform_to_downloader = {
        # ... 现有平台
        "新平台": NewPlatformDownloader,
    }
```

### 步骤3：添加域名映射

```json
// configs/business_config.json
{
  "DOMAIN_TO_NAME": {
    "www.newplatform.com": "新平台"
  }
}
```

## 九、依赖清单

```txt
# requirements.txt
fastapi>=0.104.0
uvicorn>=0.24.0
requests>=2.31.0
beautifulsoup4>=4.12.0
lxml>=4.9.0
py-mini-racer>=0.6.0
python-dotenv>=1.0.0
pydantic>=2.0.0
```

## 十、关键技术点总结

1. **工厂模式解耦**：通过字典映射实现平台与下载器的解耦，便于扩展
2. **模板方法抽象**：基类定义通用逻辑，子类实现平台特定解析
3. **正则提取JSON**：从 `<script>` 标签中提取 `window.__XXX__` 变量
4. **JS签名执行**：使用 `py-mini-racer` 执行 JS 代码生成签名
5. **重试机制**：使用 `urllib3.Retry` 实现请求重试
6. **流式下载**：使用 `iter_content` 分块下载大文件
7. **URL重定向追踪**：处理短链接到真实链接的重定向
